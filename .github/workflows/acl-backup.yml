name: Backup ledger

permissions:
  id-token: write
  contents: read

on:
  workflow_dispatch:
    inputs:
      deployment_name:
        type: string
        description: "Name of the deployment"
        default: "depa-inferencing-kms"
  workflow_call:
    inputs:
      deployment_name:
        type: string
        description: "Name of the deployment"
        default: "depa-inferencing-kms"

jobs:
  deploy:
    name: ${{ inputs.deployment_name || 'depa-inferencing-kms' }}
    runs-on: ubuntu-latest
    continue-on-error: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Log into Azure
        uses: azure/login@v2
        with:
          # Use a managed identity to authenticate to Azure
          # Use properties such as client-id, tenant-id, and subscription-id in the secrets and vars
          # The managed identity should have a federated credential with subject identiier repo:<organization>/<repo>:pull_request
          # Use subject identifier repo:<organization>/<repo>:ref:refs/heads/<branch> for running manual CI's
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Backup ledger
        env:
          DEPLOYMENT_NAME: ${{ inputs.deployment_name || 'depa-inferencing-kms' }}
          SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
          STORAGE_ACCOUNT: ${{ secrets.AZURE_KMS_BACKUP_STORAGE_ACCOUNT }}
          FILESHARE_NAME: ${{ secrets.AZURE_KMS_BACKUP_FILESHARE }}
          RESTORE_REGION: ${{ secrets.AZURE_KMS_BACKUP_REGION }}
        run: |
          set -euo pipefail

          echo "Starting backup for deployment '${DEPLOYMENT_NAME}'"
          echo "Subscription: ${SUBSCRIPTION_ID}"
          echo "Resource group: ${RESOURCE_GROUP}"
          echo "Storage account: ${STORAGE_ACCOUNT}"
          echo "Fileshare: ${FILESHARE_NAME}"
          echo "Restore region: ${RESTORE_REGION}"

          if [ -z "${STORAGE_ACCOUNT:-}" ]; then
            echo "STORAGE_ACCOUNT secret (AZURE_KMS_BACKUP_STORAGE_ACCOUNT) is required" >&2
            exit 1
          fi

          if [ -z "${FILESHARE_NAME:-}" ]; then
            echo "FILESHARE_NAME secret (AZURE_KMS_BACKUP_FILESHARE) is required" >&2
            exit 1
          fi

          # Generate SAS token for the fileshare (valid for 1 day)
          # Permissions: rwdl (read, write, delete, list)
          EXPIRY=$(date -u -d "+1 day" +"%Y-%m-%dT%H:%MZ")
          echo "Generating SAS token that expires at ${EXPIRY}"
          SAS_TOKEN=$(az storage share generate-sas \
            --account-name "$STORAGE_ACCOUNT" \
            --name "$FILESHARE_NAME" \
            --permissions rwdl \
            --expiry "$EXPIRY" \
            --https-only \
            --output tsv)
          echo "SAS token generated (length ${#SAS_TOKEN})"

          # Construct the full SAS URI
          BACKUP_SAS_URI="https://${STORAGE_ACCOUNT}.file.core.windows.net/${FILESHARE_NAME}?${SAS_TOKEN}"
          echo "Generated SAS URI for backup"

          echo "Requesting ARM access token for https://management.azure.com"
          MANAGEMENT_TOKEN=$(az account get-access-token --resource https://management.azure.com | jq -r '.accessToken')
          echo "Received ARM access token"

          API_VERSION="2024-09-19-preview"
          URL="https://management.azure.com/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${RESOURCE_GROUP}/providers/Microsoft.ConfidentialLedger/ledgers/${DEPLOYMENT_NAME}/backup?api-version=${API_VERSION}"

          # Build request body per docs: https://learn.microsoft.com/en-us/rest/api/resource-manager/confidentialledger/ledger/backup?view=rest-resource-manager-confidentialledger-2024-09-19-preview&tabs=HTTP
          BODY=$(jq -n --arg uri "$BACKUP_SAS_URI" --arg rr "$RESTORE_REGION" '{uri: $uri, restoreRegion: $rr}')

          echo "Calling backup for ledger '${DEPLOYMENT_NAME}' in resource group '${RESOURCE_GROUP}' with body '${BODY}'"
          HTTP_CODE=$(curl -sS -o response.json -w "%{http_code}" -X POST "$URL" \
            -H "Authorization: Bearer $MANAGEMENT_TOKEN" \
            -H "Content-Type: application/json" \
            --data "$BODY")

          echo "HTTP $HTTP_CODE"
          cat response.json || true

          if [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "202" ]; then
            echo "Backup request failed" >&2
            exit 1
          fi

          MESSAGE=$(jq -r '.message // empty' response.json)
          if [ -n "$MESSAGE" ]; then
            echo "Backup service message: $MESSAGE"
          fi
          echo "Ledger backup triggered successfully"
